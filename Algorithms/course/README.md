# Definition
* Algorithm = Algorithm is written at Design time
* Program = Program is written at Implementation time

# To Read
* Asymptotic Notations will be used to represent Time Complexity & Space Complexity of an Alogrithm
* Worst case --- It defines the input for which the algorithm takes a huge time.
* Average case --- It takes average time for the program execution.
* Best case --- It defines the input for which the algorithm takes the lowest time
* We need algorithms because of the Scalability and Performance
* We should focus on howmany comparisions are needed to search an element

# Terminology
* Algorithm Complexity
* Time complexity
* Space complexity = Auxiliary space + Input size
* Operations = Searching,Sorting,Insertion,Updation,Deletion

# Types of Algorithms
* Searching Algorithm
* Sorting Algorithm

# Searching & Sorting Algorithm
|#SNo| #Algorithm  | #Comments |
| :--- | :--- | :--- | 
|1| Searching Algorithm | 1. [Linear Search](https://www.javatpoint.com/linear-search) <br>2. [Binary Search](https://www.javatpoint.com/binary-search)|
|2| Sorting Algorithm | 1. [Bubble Sort](https://www.javatpoint.com/bubble-sort) <br>2. [Bucket Sort](https://www.javatpoint.com/bucket-sort) <br>3. [Comb Sort](https://www.javatpoint.com/comb-sort) <br>4. [Counting Sort](https://www.javatpoint.com/counting-sort) <br>5. [Heap Sort](https://www.javatpoint.com/heap-sort) <br>6. [Insertion Sort](https://www.javatpoint.com/insertion-sort) <br>7. [Merge Sort](https://www.javatpoint.com/merge-sort) <br>8. [Quick Sort](https://www.javatpoint.com/quick-sort) <br>9. [Radix Sort](https://www.javatpoint.com/radix-sort) <br>10. [Selection Sort](https://www.javatpoint.com/selection-sort) <br>11. [Shell Sort](https://www.javatpoint.com/shell-sort) <br>12. [Bitonic Sort](https://www.javatpoint.com/bitonic-sort) <br>13. [Cocktail Sort](https://www.javatpoint.com/cocktail-sort) <br>14. [Cycle Sort](https://www.javatpoint.com/cycle-sort) <br>15. [Tim Sort](https://www.javatpoint.com/tim-sort) |


# Searching Algorithm
|#SNo| #Algorithm  | #Approach |#Time Complexity | #Space Complexity |
| :--- | :--- | :--- |:--- |:--- |
|1| [Linear Search](https://www.javatpoint.com/linear-search) |Approach |![image](https://user-images.githubusercontent.com/7721150/163672267-a20e0090-6f73-4eab-911a-a3e10f15fc5b.png) |![image](https://user-images.githubusercontent.com/7721150/163672279-bb670ef3-10a2-462a-ae8c-713881076b2b.png) |
|2| [Binary Search](https://www.javatpoint.com/binary-search) |1. Iterative Method <br>2. Recursive Method(Divide & Conquers Approach)| ![image](https://user-images.githubusercontent.com/7721150/163672426-bc8e6a9d-409f-4ec1-9fec-975d0a49826f.png)|![image](https://user-images.githubusercontent.com/7721150/163672445-0df32fef-7d46-4113-b627-ab1bfb7d237c.png) |


# Sorting Algorithm
|#SNo| #Algorithm  | #Approach |#Time Complexity | #Space Complexity |
| :--- | :--- | :--- |:--- |:--- |
|1| [Bubble Sort](https://www.javatpoint.com/bubble-sort) |Approach| 1.Best Case = O(n)<br>2.Average Case = O(n2)<br>3.Worst Case = O(n2)| 1. The space complexity of bubble sort is O(1). It is because, in bubble sort, an extra 1 variable is required for swapping <br>2. The space complexity of optimized bubble sort is O(2). It is because  extra 2 variables are required in optimized bubble sort |
|2|[Merge Sort](https://www.javatpoint.com/merge-sort)|Approach|1.Best Case = O(n*logn)<br>2.Average Case = O(n*logn)<br>3.Worst Case = O(n*logn)|The space complexity of merge sort is O(n). It is because, in merge sort, an extra variable is required for swapping|
|3|[Quick Sort](https://www.javatpoint.com/quick-sort)|Approach|1.Best Case = O(n*logn)<br>2.Average Case = O(n*logn)<br>3.Worst Case = O(n2)|The space complexity of quick sort is O(n*logn)|

# Asymptotic Notations
1. Big oh Notation (O) --- ( Worst case )
2. Omega Notation (Ω) --- ( Average case )
3. Theta Notation (θ) --- ( Best case )
* ![image](https://user-images.githubusercontent.com/7721150/180755536-c0ad849e-4f37-470d-982e-07e17db2c755.png)


# Asymptotic Notations Representation
|SNo| #Type  | #Notation |
| :--- | :--- | :--- |
| 1 | constant | O(1) |
| 2 | linear |O(n) |
| 3 | logarithmic |O(log n) |
| 4 | n log n |O(n log n) |
| 5 | exponential |2O(n) |
| 6 | cubic |O(n3) |
| 7 | polynomial |nO(1) |
| 8 | quadratic |O(n2) |



# Reference
* [Algorithm - Abdul Bari - YouTube](https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O)
* [Why is O(N) sorting impossible?](https://www.youtube.com/watch?v=4Q72kbwyEmk&list=RDCMUCRPMAqdtSgd0Ipeef7iFsKw&index=25)
* [BFS Algorithm](https://www.javatpoint.com/breadth-first-search-algorithm)
* [Is-O-log-n-always-faster-than-O-n -- Quora](https://www.quora.com/Is-O-log-n-always-faster-than-O-n)
  
# Images
1. Asymptotic Notations Representation
* ![image](https://user-images.githubusercontent.com/7721150/177767972-8abe6522-fcaf-429c-8a70-7056b646e6b7.png)
2. Big O Complexity
* ![image](https://user-images.githubusercontent.com/7721150/177769322-aa6fb00d-6bbe-4fe6-b854-0b48faae3bd9.png)
3. Algorithm VS Program
* ![image](https://user-images.githubusercontent.com/7721150/180744014-4b6905d8-9a3c-45c2-8592-7dfad6606884.png)



