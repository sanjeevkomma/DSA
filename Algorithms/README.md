# Definition

# To Read
* Asymptotic Notations will be used to represent Time Complexity & Space Complexity of an Alogrithm
* Worst case --- It defines the input for which the algorithm takes a huge time.
* Average case --- It takes average time for the program execution.
* Best case --- It defines the input for which the algorithm takes the lowest time
* We need algorithms because of the Scalability and Performance

# Terminology
* Algorithm Complexity
* Time complexity
* Space complexity = Auxiliary space + Input size
* Operations = Searching,Sorting,Insertion,Updation,Deletion

# Types of Algorithms
* Searching Algorithm
* Sorting Algorithm

# Searching & Sorting Algorithm
| #Algorithm  | #Comments |
| :---: | :---: | 
| Searching Algorithm | 1. [Linear Search](https://www.javatpoint.com/linear-search) 2. [Binary Search](https://www.javatpoint.com/binary-search)|
| Sorting Algorithm | 1. [Bubble Sort](https://www.javatpoint.com/bubble-sort) 2. [Bucket Sort](https://www.javatpoint.com/bucket-sort) 3. [Comb Sort](https://www.javatpoint.com/comb-sort) 4. [Counting Sort](https://www.javatpoint.com/counting-sort) 5. [Heap Sort](https://www.javatpoint.com/heap-sort) 6. [Insertion Sort](https://www.javatpoint.com/insertion-sort) 7. [Merge Sort](https://www.javatpoint.com/merge-sort) 8. [Quick Sort](https://www.javatpoint.com/quick-sort) 9. [Radix Sort](https://www.javatpoint.com/radix-sort) 10. [Selection Sort](https://www.javatpoint.com/selection-sort) 11. [Shell Sort](https://www.javatpoint.com/shell-sort) 12. [Bitonic Sort](https://www.javatpoint.com/bitonic-sort) 13. [Cocktail Sort](https://www.javatpoint.com/cocktail-sort) 14. [Cycle Sort](https://www.javatpoint.com/cycle-sort) 15. [Tim Sort](https://www.javatpoint.com/tim-sort) |


# Searching Algorithm
| #Algorithm  | #Time Complexity | #Space Complexity |
| :---: | :---: | :---: |
| [Linear Search](https://www.javatpoint.com/linear-search) | ![image](https://user-images.githubusercontent.com/7721150/163672267-a20e0090-6f73-4eab-911a-a3e10f15fc5b.png) |![image](https://user-images.githubusercontent.com/7721150/163672279-bb670ef3-10a2-462a-ae8c-713881076b2b.png) |
| [Binary Search](https://www.javatpoint.com/binary-search) | ![image](https://user-images.githubusercontent.com/7721150/163672426-bc8e6a9d-409f-4ec1-9fec-975d0a49826f.png)|![image](https://user-images.githubusercontent.com/7721150/163672445-0df32fef-7d46-4113-b627-ab1bfb7d237c.png) |


# Sorting Algorithm
| #Algorithm  | #Time Complexity | #Space Complexity |
| :---: | :---: | :---: |
| [Bubble Sort](https://www.javatpoint.com/bubble-sort) | Best Case = O(n) , Average Case = O(n2) , Worst Case = O(n2)| 1. The space complexity of bubble sort is O(1). It is because, in bubble sort, an extra 1 variable is required for swapping 2. The space complexity of optimized bubble sort is O(2). It is because  extra 2 variables are required in optimized bubble sort |
|[Merge Sort](https://www.javatpoint.com/merge-sort)|Best Case = O(n*logn) , Average Case = O(n*logn), Worst Case = O(n*logn)|The space complexity of merge sort is O(n). It is because, in merge sort, an extra variable is required for swapping|

# Asymptotic Notations
1. Big oh Notation (O) --- ( Worst case )
2. Omega Notation (Ω) --- ( Average case )
3. Theta Notation (θ) --- ( Best case )

# Asymptotic Notations Representation
1. constant --- O(1)
2. linear --- O(n)
3. logarithmic --- 	O(log n)
4. n log n --- O(n log n)
5. exponential --- 2O(n)
6. cubic --- O(n3)
7. polynomial --- nO(1)
8. quadratic --- O(n2)


# Reference
* [Why is O(N) sorting impossible?](https://www.youtube.com/watch?v=4Q72kbwyEmk&list=RDCMUCRPMAqdtSgd0Ipeef7iFsKw&index=25)
* [BFS Algorithm](https://www.javatpoint.com/breadth-first-search-algorithm)
  
