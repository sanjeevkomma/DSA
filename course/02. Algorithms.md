# Definition
* Algorithm = Algorithm is written at Design time
* Program = Program is written at Implementation time

# To Read
* Asymptotic Notations will be used to represent Time Complexity & Space Complexity of an Alogrithm
* Worst case --- It defines the input for which the algorithm takes a huge time.
* Average case --- It takes average time for the program execution.
* Best case --- It defines the input for which the algorithm takes the lowest time
* We need algorithms because of the Scalability and Performance
* We should focus on howmany comparisions are needed to search an element
* Space complexity = O(1) = It means no extra space is required

# Terminology
* Algorithm Complexity
* Time complexity
* Space complexity = Auxiliary space + Input size
* Operations = Searching,Sorting,Insertion,Updation,Deletion

# Types of Algorithms
|#SNo| #Algorithm  | #Comments |
| :--- | :--- | :--- | 
|1| Searching Algorithm | 1. [Linear Search](https://www.javatpoint.com/linear-search) <br>2. [Binary Search](https://www.javatpoint.com/binary-search) <br>3. Jump Search <br>4. Interpolation Search<br> 5. Depth First Search (DFS)<br> 6. Breadth First Search (BFS)|
|2| Sorting Algorithm | 1. [Bubble Sort](https://www.javatpoint.com/bubble-sort) <br>2. [Bucket Sort](https://www.javatpoint.com/bucket-sort) <br>3. [Comb Sort](https://www.javatpoint.com/comb-sort) <br>4. [Counting Sort](https://www.javatpoint.com/counting-sort) <br>5. [Heap Sort](https://www.javatpoint.com/heap-sort) <br>6. [Insertion Sort](https://www.javatpoint.com/insertion-sort) <br>7. [Merge Sort](https://www.javatpoint.com/merge-sort) <br>8. [Quick Sort](https://www.javatpoint.com/quick-sort) <br>9. [Radix Sort](https://www.javatpoint.com/radix-sort) <br>10. [Selection Sort](https://www.javatpoint.com/selection-sort) <br>11. [Shell Sort](https://www.javatpoint.com/shell-sort) <br>12. [Bitonic Sort](https://www.javatpoint.com/bitonic-sort) <br>13. [Cocktail Sort](https://www.javatpoint.com/cocktail-sort) <br>14. [Cycle Sort](https://www.javatpoint.com/cycle-sort) <br>15. [Tim Sort](https://www.javatpoint.com/tim-sort) |
|3| Divide & Conquer Algorithm | 1. Merge Sort<br> 2. Quick Sort<br> 3. Binary Search<br> 4. Strassen’s Matrix Multiplication|
|4| Hashing Algorithm | |
|5| Greedy Algorithm | 1. Dijkstra’s Algorithm<br>2. Kruskal’s / Prim’s<br>3. Activity Selection<br>4. Huffman Coding|
|6| Recursion Algorithm | |
|7| Backtracking Algorithm | 1. N-Queens Problem<br>2. Sudoku Solver<br>3. Rat in a Maze<br>4. Word Search in Matrix|
|8| Tree Traversal Algorithm | |
|9| Graph Traversal Algorithm | 1. DFS / BFS<br>2. Dijkstra / Bellman-Ford<br>3. Floyd-Warshall<br>4. Kruskal / Prim<br>5. Topological Sort|
|10| Dynamic Programming Algorithm |1. Fibonacci Series<br>2. 0/1 Knapsack Problem<br>3. Longest Common Subsequence<br>4. Matrix Chain Multiplication |
|11| Branch and Bound Algorithm | 1. Travelling Salesman<br>2. 0/1 Knapsack (optimal)|
|12| Bit Manipulation Algorithms | 1. Counting set bits<br>2. Power of two check<br>3. XOR-based swaps|
|13|Mathematical Algorithms | 1. Number theory<br>2. Geometry<br>3. Combinatorics<br>4. Algebra

# Algorithm , Time Complexity , Space Complexity
* ![image](https://user-images.githubusercontent.com/7721150/180968553-4f0c1f0e-3d0b-45e6-ad91-1e81565aecc1.png)


# Searching Algorithm
|#SNo| #Algorithm  |#Data Structure |#Approach |#Time Complexity | #Space Complexity |
| :--- | :--- | :--- |:--- |:--- |:--- |
|1| [Linear Search](https://www.javatpoint.com/linear-search) |Array <br>int arr[] = {1,2};|Approach |1.Best Case = O(1)<br>2.Average Case = O(n)<br>3.Worst Case = O(n) |O(1) |
|2| [Binary Search](https://www.javatpoint.com/binary-search) |Array <br>int arr[] = {1,2};|1. Iterative Method <br>2. Recursive Method(Divide & Conquers Approach)| 1.Best Case = O(1)<br>2.Average Case = O(logn)<br>3.Worst Case = O(logn)|O(1) |


# Sorting Algorithm
|#SNo| #Algorithm  |#Data Structure| #Approach |#Time Complexity | #Space Complexity |
| :--- | :--- | :--- |:--- |:--- |:--- |
|1| [Bubble Sort](https://www.javatpoint.com/bubble-sort) |Array <br>int arr[] = {1,2};|Approach| 1.Best Case = O(n)<br>2.Average Case = O(n2)<br>3.Worst Case = O(n2)| 1. The space complexity of bubble sort is O(1). It is because, in bubble sort, an extra 1 variable is required for swapping <br>2. The space complexity of optimized bubble sort is O(2). It is because  extra 2 variables are required in optimized bubble sort |
|2|[Merge Sort](https://www.javatpoint.com/merge-sort)|Array <br>int arr[] = {1,2};|Approach|1.Best Case = O(n*logn)<br>2.Average Case = O(n*logn)<br>3.Worst Case = O(n*logn)|The space complexity of merge sort is O(n). It is because, in merge sort, an extra variable is required for swapping|
|3|[Quick Sort](https://www.javatpoint.com/quick-sort)|Array <br>int arr[] = {1,2};|Approach|1.Best Case = O(n*logn)<br>2.Average Case = O(n*logn)<br>3.Worst Case = O(n2)|The space complexity of quick sort is O(n*logn)|

# Asymptotic Notations
1. Big oh Notation (O) --- ( Worst case )
2. Omega Notation (Ω) --- ( Average case )
3. Theta Notation (θ) --- ( Best case )
* ![image](https://user-images.githubusercontent.com/7721150/180755536-c0ad849e-4f37-470d-982e-07e17db2c755.png)


# Asymptotic Notations Representation
|SNo| #Type  | #Notation |
| :--- | :--- | :--- |
| 1 | constant | O(1) |
| 2 | linear |O(n) |
| 3 | logarithmic |O(log n) |
| 4 | n log n |O(n log n) |
| 5 | exponential |2O(n) |
| 6 | cubic |O(n3) |
| 7 | polynomial |nO(1) |
| 8 | quadratic |O(n2) |



# Reference
* [Algorithm - Abdul Bari - YouTube](https://www.youtube.com/playlist?list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O)
* [Why is O(N) sorting impossible?](https://www.youtube.com/watch?v=4Q72kbwyEmk&list=RDCMUCRPMAqdtSgd0Ipeef7iFsKw&index=25)
* [BFS Algorithm](https://www.javatpoint.com/breadth-first-search-algorithm)
* [Is-O-log-n-always-faster-than-O-n -- Quora](https://www.quora.com/Is-O-log-n-always-faster-than-O-n)
  
# Images
1. Asymptotic Notations Representation
* ![image](https://user-images.githubusercontent.com/7721150/177767972-8abe6522-fcaf-429c-8a70-7056b646e6b7.png)
2. Big O Complexity
* ![image](https://user-images.githubusercontent.com/7721150/177769322-aa6fb00d-6bbe-4fe6-b854-0b48faae3bd9.png)
3. Algorithm VS Program
* ![image](https://user-images.githubusercontent.com/7721150/180744014-4b6905d8-9a3c-45c2-8592-7dfad6606884.png)
4. Algorithms & Techniques
* ![image](https://github.com/user-attachments/assets/06efdcb5-8fa2-4615-8b34-a8ec0201ee87)



# Notes
* Type : Time complexity : Space Complexity 
* Linear Search : O(n) : O(1) : Iteration , Unsorted
* Binary Search : O(logn) : O(1) : Recursion, Sorted, Mid Index 
* Bubble Sort : O(n2) : O(1) : Iteration Method , Swapping
* Merge Sort : O(nlogn) : O(n) : Divide & Conquer, Recursion, mergeSort, mergeSort, merge
* Quick Sort : O(n2) : O(logn) : Divide & Conquer, Recursion, partition, quickSort, quickSort
